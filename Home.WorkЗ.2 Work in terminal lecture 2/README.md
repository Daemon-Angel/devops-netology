# Домашнее задание к занятию "3.2. Работа в терминале, лекция 2"

#### 1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.
#### Ответ:
`user@Daemon:~$ type cd`

`cd — это встроенная команда bash`

Данная команда `cd` (change directory), имеет тип встроенной, т.к. она как и многие другие команды необходима для удобного функционирования с директориями и файлами Linux, конечно можно себе представить что команда `cd` была бы к примеру внешней прогаммой, но тогда бы пришлось каждый раз при необходимости тратить время на запуск данной программы отдельно от нашей сессии, а также пришлось бы как то синхронизировать работу `bash` и работу `cd` чтобы та могла отслеживать создания или какие-либо действия внутри `bash`, что влияло бы и на скорость.

#### 2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.
#### Ответ:
`user@Daemon:~$ cat test-grep.txt`

`12345`

`Hello world`

`test`

`user@Daemon:~$ grep 12345 test-grep.txt -c`

`1`

`user@Daemon:~$ grep 12345 test-grep.txt |wc -l`

`1`

#### 3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?
#### Ответ:
`vagrant@vagrant:~$ pstree -p`

`systemd(1)─┬─VBoxService(919)─┬─{VBoxService}(920)`

           `│                  ├─{VBoxService}(922)`       
           `│                  ├─{VBoxService}(923)`      
           `│                  ├─{VBoxService}(924)` 
           `│                  ├─{VBoxService}(925)`
           `│                  ├─{VBoxService}(926)`
           `│                  ├─{VBoxService}(927)`
           `                   └─{VBoxService}(929)`
           
#### 4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?
#### Ответ:
 Вызов из pts/0:

`vagrant@vagrant:~$ who`

`vagrant  pts/0        2022-01-20 23:42 (10.0.2.2)`

`vagrant  pts/1        2022-01-20 23:43 (10.0.2.2)`
 
`vagrant@vagrant:~$ ls -l \test 2>/dev/pts/1`

`vagrant@vagrant:~$` 
    
Вывод в другой сессии pts/1:    

`vagrant@vagrant:~$ ls: cannot access 'test': No such file or directory`

#### 5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
#### Ответ:
`user@Daemon:~$ cat test-grep.txt`

`12345`

`Hello world`

`test`

`user@Daemon:~$ cat test-grep-out.txt`

`cat: test-grep-out: No such file or directory`

`user@Daemon:~$ cat <test-grep.txt >test-grep-out.txt`

`user@Daemon:~$ cat test-grep-out.txt`

`12345`

`Hello world`

`test`

`user@Daemon:~$`

#### 6. Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?
#### Ответ:
Необходимо перенаправить вывод:

`vagrant@vagrant:~$ tty`

`/dev/pts/0`

`vagrant@vagrant:~$ echo Hello world from pts/0 to tty3 >/dev/tty3`

`vagrant@vagrant:~$`

Выводимые данные можно наблюдать после переключения в контекст tty (Ctrl-Alt-F3):
![изображение](https://user-images.githubusercontent.com/94983313/150655462-ba9d2255-036e-4963-9098-0ae3bf787970.png)

И соответствено, можно вывести контекст ответом из tty в pty, а наблюдать его можно после возврата в графический режим:

`vagrant@vagrant:~$ Hello world from tty3 to pts0`

#### 7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит?
#### Ответ:
`bash 5>&1` запустит bash с дополнительным файловым дескриптором "5" и перенаправит его в (stdout).

`echo netology > /proc/$$/fd/5` выведет в терминал слово "netology". А происходит это так потому, что echo отправляет netology в файловый дескриптор с номером 5 текущего shell (файловая система proc содержит информацию о запущенных процессах по их PID, $$ - подставит PID текущего shell, в "папке" fd можно посмотреть на какие файлы ссылаются дескрипторы по номерам)

`vagrant@vagrant:~$ bash 5>&1`

`vagrant@vagrant:~$ echo netology > /proc/$$/fd/5`

`netology`

`vagrant@vagrant:~$`

#### 8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.
#### Ответ: 
Да

`vagrant@vagrant:~$ ls -l /root 8>&2 2>&1 1>&8 |grep denied -c` 

`1`

Сначала новый дескриптор перенаправили в stderr, затем stderr перенаправили в stdout и stdout - перенаправили в новый дескриптор.

#### 9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?
#### Ответ:
Будут выведены переменные окружения.
Аналогичный по содержанию вывод можно получить с помощью:

`printenv`

`env -0`
#### 10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.
#### Ответ:

`/proc/<PID>/cmdline` - полный путь до исполняемого файла процесса [PID]  (строка 231)

`/proc/<PID>/exe` - содержит ссылку до файла запущенного для процесса [PID], 
                        cat выведет содержимое запущенного файла, 
                        запуск этого файла,  запустит еще одну копию самого файла  (строка 285)

#### 11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.
#### Ответ:
SSE 4.2

`vagrant@vagrant:~$ grep sse /proc/cpuinfo`
#### 12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

`vagrant@netology1:~$ ssh localhost 'tty'`

`not a tty`

Почитайте, почему так происходит, и как изменить поведение.
#### Ответ:
Почитал: самый понятный ответ на вопрос - при подключении ожидается пользователь, а не другой процесс, и нет локального tty в данный момент; А также похожая ситуация возникает, когда подключаешься по ssh к одной машине, а потом еще из под неё по ssh к следующей машине.
для запуска можно добавить -t и команда исполняется c принудительным созданием псевдотерминала.

#### 13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, который вы запустили по ошибке в обычной SSH-сессии.
#### Ответ:
`user@Daemon:~$ ping 127.0.0.1`

`PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.`

`64 bytes from 127.0.0.1: icmp_seq=1 ttl=64 time=0.025 ms`

`64 bytes from 127.0.0.1: icmp_seq=2 ttl=64 time=0.045 ms`

`^Z`

`[1]+  Остановлен    ping 127.0.0.1`

`user@Daemon:~$ jobs -l`

`[1]+ 25460 Остановлено  ping 127.0.0.1`

`user@Daemon:~$ reptyr 25460`

#### 14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.
#### Ответ:
Команда `tee` нужна для записи вывода любой команды в один или несколько файлов/ принимает данные из одного источника и может сохранять их на выходе в нескольких местах, а `echo` - это не системная утилита, это командный инструмент Unix / Linux, используемый для отображения строк текста или строки, которые передаются в качестве аргументов в командной строке,у нее нет исполняемого файла, она существует только внутри интерпретатора Bash.














